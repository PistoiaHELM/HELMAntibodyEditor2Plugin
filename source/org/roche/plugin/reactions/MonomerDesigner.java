/*******************************************************************************
 * Copyright C 2016, Roche pREDi (Roche Innovation Center Munich)
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
 * Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

package org.roche.plugin.reactions;

import java.awt.Cursor;
import java.awt.Insets;
import java.io.IOException;
import java.util.LinkedList;
import java.util.Map;

import javax.swing.JOptionPane;
import javax.swing.UIManager;
import javax.swing.plaf.basic.BasicTabbedPaneUI;

import org.helm.notation.MonomerFactory;
import org.helm.notation.MonomerStore;
import org.helm.notation.model.Attachment;
import org.helm.notation.model.Monomer;
import org.helm.notation.tools.StructureParser;
import org.roche.antibody.services.UIService;
import org.roche.plugin.reactions.models.AttachmentTableModel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import chemaxon.struc.Molecule;

import com.quattroresearch.antibody.MonomerUtils;

/**
 * 
 * {@code MonomerDesigner} may be used to show, edit or register monomers.
 * 
 * @author <b>Stefan Klostermann:</b> Stefan DOT Klostermann AT roche DOT com,
 *         Roche Pharma Research and Early Development - Informatics, Roche
 *         Innovation Center Munich
 * @author <b>Marco Erdmann:</b> erdmann AT quattro-research DOT com, quattro
 *         research GmbH
 * @author <b>Marco Lanig:</b> lanig AT quattro-research DOT com, quattro
 *         research GmbH
 * @author <b>Sabrina Hecht:</b> hecht AT quattro-research DOT com, quattro
 *         research GmbH
 * @version $Id$
 */
public class MonomerDesigner extends javax.swing.JDialog {

	/**
	 * Generated serialVersionUID;
	 */
	private static final long serialVersionUID = -5174872012738061075L;

	private static final Logger LOG = LoggerFactory
			.getLogger(MonomerDesigner.class);

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JButton btnCancel;

	private javax.swing.JButton btnSave;

	private javax.swing.JPanel jPanel1;

	private javax.swing.JScrollPane jScrollPane1;

	private javax.swing.JLabel lblTrivialName;

	private javax.swing.JLabel lblTrivialName1;

	private javax.swing.JTable tblAttachments;

	private javax.swing.JTabbedPane tpMonomerDetails;

	private javax.swing.JTextField txtTrivialName;

	// End of variables declaration//GEN-END:variables

	private MonomerViewer monomerViewer;

	private AttachmentTableModel attachmentTableModel;

	/**
	 * Creates new form ADCDesignerDialog
	 * 
	 * @param parent
	 *            the parent {@link java.awt.Frame}.
	 * @param model
	 *            the data model.
	 */
	public MonomerDesigner(java.awt.Frame parent, String title) {
		super(parent, true);
		setTitle(title);
		initComponents();
		initMonomerViewers();
		initAttachmentTable();
		// setCategory1();
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	@SuppressWarnings({ "unchecked" })
	// <editor-fold defaultstate="collapsed"
	// <editor-fold defaultstate="collapsed" desc="Generated
	// Code">//GEN-BEGIN:initComponents
	private void initComponents() {

		lblTrivialName1 = new javax.swing.JLabel();
		tpMonomerDetails = new javax.swing.JTabbedPane();
		jScrollPane1 = new javax.swing.JScrollPane();
		tblAttachments = new javax.swing.JTable();
		jPanel1 = new javax.swing.JPanel();
		btnSave = new javax.swing.JButton();
		btnCancel = new javax.swing.JButton();
		txtTrivialName = new javax.swing.JTextField();
		lblTrivialName = new javax.swing.JLabel();

		lblTrivialName1.setText("Trivial Name");

		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

		jScrollPane1.setMaximumSize(new java.awt.Dimension(100, 100));
		jScrollPane1.setPreferredSize(new java.awt.Dimension(100, 100));

		tblAttachments
				.setModel(new javax.swing.table.DefaultTableModel(
						new Object[][] { { null, null }, { null, null },
								{ null, null } }, new String[] {
								"Attachment Point", "Leaving Group" }) {
					Class[] types = new Class[] { java.lang.String.class,
							java.lang.String.class };

					@Override
					public Class getColumnClass(int columnIndex) {
						return types[columnIndex];
					}
				});
		tblAttachments.setPreferredSize(new java.awt.Dimension(100, 64));
		jScrollPane1.setViewportView(tblAttachments);

		btnSave.setText("Save");
		btnSave.addActionListener(new java.awt.event.ActionListener() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				btnSaveActionPerformed(evt);
			}
		});

		btnCancel.setText("Cancel");
		btnCancel.addActionListener(new java.awt.event.ActionListener() {
			@Override
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				btnCancelActionPerformed(evt);
			}
		});

		javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(
				jPanel1);
		jPanel1.setLayout(jPanel1Layout);
		jPanel1Layout
				.setHorizontalGroup(jPanel1Layout
						.createParallelGroup(
								javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(
								javax.swing.GroupLayout.Alignment.TRAILING,
								jPanel1Layout
										.createSequentialGroup()
										.addContainerGap(
												javax.swing.GroupLayout.DEFAULT_SIZE,
												Short.MAX_VALUE)
										.addComponent(btnSave)
										.addPreferredGap(
												javax.swing.LayoutStyle.ComponentPlacement.RELATED)
										.addComponent(btnCancel)
										.addContainerGap()));
		jPanel1Layout
				.setVerticalGroup(jPanel1Layout
						.createParallelGroup(
								javax.swing.GroupLayout.Alignment.LEADING)
						.addGroup(
								jPanel1Layout
										.createSequentialGroup()
										.addContainerGap(
												javax.swing.GroupLayout.DEFAULT_SIZE,
												Short.MAX_VALUE)
										.addGroup(
												jPanel1Layout
														.createParallelGroup(
																javax.swing.GroupLayout.Alignment.BASELINE)
														.addComponent(btnSave)
														.addComponent(btnCancel))
										.addContainerGap()));

		lblTrivialName.setText("Name");

		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(
				getContentPane());
		getContentPane().setLayout(layout);
		layout.setHorizontalGroup(layout
				.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGroup(
						layout.createSequentialGroup()
								.addContainerGap()
								.addGroup(
										layout.createParallelGroup(
												javax.swing.GroupLayout.Alignment.LEADING)
												.addComponent(
														jPanel1,
														javax.swing.GroupLayout.DEFAULT_SIZE,
														javax.swing.GroupLayout.DEFAULT_SIZE,
														Short.MAX_VALUE)
												.addGroup(
														layout.createSequentialGroup()
																.addComponent(
																		tpMonomerDetails,
																		javax.swing.GroupLayout.PREFERRED_SIZE,
																		432,
																		javax.swing.GroupLayout.PREFERRED_SIZE)
																.addPreferredGap(
																		javax.swing.LayoutStyle.ComponentPlacement.RELATED)
																.addGroup(
																		layout.createParallelGroup(
																				javax.swing.GroupLayout.Alignment.LEADING)
																				.addComponent(
																						jScrollPane1,
																						javax.swing.GroupLayout.DEFAULT_SIZE,
																						javax.swing.GroupLayout.DEFAULT_SIZE,
																						Short.MAX_VALUE)
																				.addGroup(
																						layout.createSequentialGroup()
																								.addComponent(
																										lblTrivialName,
																										javax.swing.GroupLayout.PREFERRED_SIZE,
																										84,
																										javax.swing.GroupLayout.PREFERRED_SIZE)
																								.addPreferredGap(
																										javax.swing.LayoutStyle.ComponentPlacement.RELATED)
																								.addComponent(
																										txtTrivialName,
																										javax.swing.GroupLayout.DEFAULT_SIZE,
																										190,
																										Short.MAX_VALUE)))
																.addContainerGap()))));
		layout.setVerticalGroup(layout
				.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
				.addGroup(
						layout.createSequentialGroup()
								.addGroup(
										layout.createParallelGroup(
												javax.swing.GroupLayout.Alignment.LEADING)
												.addGroup(
														layout.createSequentialGroup()
																.addContainerGap()
																.addComponent(
																		tpMonomerDetails))
												.addGroup(
														layout.createSequentialGroup()
																.addGap(21, 21,
																		21)
																.addGroup(
																		layout.createParallelGroup(
																				javax.swing.GroupLayout.Alignment.BASELINE)
																				.addComponent(
																						lblTrivialName)
																				.addComponent(
																						txtTrivialName,
																						javax.swing.GroupLayout.PREFERRED_SIZE,
																						javax.swing.GroupLayout.DEFAULT_SIZE,
																						javax.swing.GroupLayout.PREFERRED_SIZE))
																.addPreferredGap(
																		javax.swing.LayoutStyle.ComponentPlacement.RELATED,
																		125,
																		Short.MAX_VALUE)
																.addComponent(
																		jScrollPane1,
																		javax.swing.GroupLayout.PREFERRED_SIZE,
																		javax.swing.GroupLayout.DEFAULT_SIZE,
																		javax.swing.GroupLayout.PREFERRED_SIZE)))
								.addPreferredGap(
										javax.swing.LayoutStyle.ComponentPlacement.RELATED)
								.addComponent(jPanel1,
										javax.swing.GroupLayout.PREFERRED_SIZE,
										javax.swing.GroupLayout.DEFAULT_SIZE,
										javax.swing.GroupLayout.PREFERRED_SIZE)
								.addContainerGap()));

		pack();
	}// </editor-fold>//GEN-END:initComponents

	private void btnSaveActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_btnSaveActionPerformed
		Molecule molecule = monomerViewer.getMol();

		// ME 2015-09-10: [TAP-1451], perform some sanity checks
		String molfile = molecule.toFormat("mol");
		String smiles = molecule
				.toFormat(StructureParser.CHEMAXON_EXTENDEND_SMILES_FORMAT);

		try {
			// JL 2015-09-14 Check if trivial name is set
			if (txtTrivialName.getText() == null
					|| txtTrivialName.getText().isEmpty()) {
				JOptionPane.showMessageDialog(UIService.getInstance()
						.getMainFrame(),
						"Please set a  name for the new monomer!",
						"Name missing", JOptionPane.ERROR_MESSAGE);
				return;
			}

			if (!MonomerUtils.hasRGroup(molfile)) {
				JOptionPane
						.showMessageDialog(
								UIService.getInstance().getMainFrame(),
								"The new monomer has no RGroups but needs at least one RGroup!",
								"No RGroup found", JOptionPane.ERROR_MESSAGE);
				return;
			}

			// JL 2015-09-14 Check if count of R-groups in mol file equals the
			// count of rests in the attachment table
			if (attachmentTableModel.getAttachmentList().size() != MonomerUtils
					.countRGroup(molfile)) {
				JOptionPane
						.showMessageDialog(
								UIService.getInstance().getMainFrame(),
								"The number of R-groups in the structure and the number of leaving groups in the table is not equal.\n Please check your input!",
								"Inconsitent number of R-groups",
								JOptionPane.ERROR_MESSAGE);
				return;
			}

			if (MonomerUtils.hasSuperAtoms(molfile)) {
				JOptionPane
						.showMessageDialog(
								UIService.getInstance().getMainFrame(),
								"The new monomer has super atoms which lead to errors with the chemistry index in the database.\nPlease remove any super atoms like NO2 or CNO etc.!",
								"Super atoms found", JOptionPane.ERROR_MESSAGE);
				return;
			}

			if (!StructureParser.validateSmiles(smiles)) {
				JOptionPane
						.showMessageDialog(
								UIService.getInstance().getMainFrame(),
								"The new monomer failed the valence check!\nPlease fix any valence errors in the structure.",
								"Valence check failed",
								JOptionPane.ERROR_MESSAGE);
				return;
			}
		} catch (IOException e) {
			JOptionPane
					.showMessageDialog(
							UIService.getInstance().getMainFrame(),
							"An unexcepted error occured during monomer validation.\nThe error was %s.\nPlease contact support.",
							"Unexpected error", JOptionPane.ERROR_MESSAGE);
			LOG.error(e.getMessage(), e);
			return;
		}

		String monomerName = txtTrivialName.getText();
		Monomer monomer = new Monomer(Monomer.CHEMICAL_POLYMER_TYPE,
				Monomer.UNDEFINED_MOMONER_TYPE, "", monomerName);
		monomer.setName(monomerName);
		monomer.setMolfile(molfile);
		monomer.setCanSMILES(smiles);
		monomer.setAlternateId(txtTrivialName.getText());

		monomer.setAttachmentList(attachmentTableModel.getAttachmentList());
		String r1 = null;
		String r2 = null;
		String r3 = null;
		try {
			Map<String, Attachment> mapAttachment = MonomerFactory
					.getInstance().getAttachmentDB();
			for (Attachment att : monomer.getAttachmentList()) {
				switch (att.getLabel()) {
				case "R1":
					r1 = att.getCapGroupName();
					att.setCapGroupSMILES(mapAttachment.get(
							att.getLabel() + "-" + att.getAlternateId())
							.getCapGroupSMILES());
					break;
				case "R2":
					r2 = att.getCapGroupName();
					att.setCapGroupSMILES(mapAttachment.get(
							att.getLabel() + "-" + att.getAlternateId())
							.getCapGroupSMILES());
					break;
				case "R3":
					r3 = att.getCapGroupName();
					att.setCapGroupSMILES(mapAttachment.get(
							att.getLabel() + "-" + att.getAlternateId())
							.getCapGroupSMILES());
					break;
				default:
					break;
				}

			}
		} catch (Exception e) {
			LOG.error("Saving monomer failed!", e);
			JOptionPane
					.showMessageDialog(UIService.getInstance().getMainFrame(),
							"Saving monomer failed: " + e.getMessage());
			return;
		}

		try {
			this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
			String molfileWithRGroups = monomer.getMolfile();
			// monomer = MonomerUtils.removeRGroupsfromMolfile(monomer);
			registerInLocalMonomerStore(monomer);
		} catch (Exception e) {
			LOG.error("Saving monomer failed!", e);
			JOptionPane
					.showMessageDialog(UIService.getInstance().getMainFrame(),
							"Saving monomer failed: " + e.getMessage());
			return;
		} finally {
			this.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
		}
		// everything ok --> close window
		dispose();
	}// GEN-LAST:event_btnSaveActionPerformed

	private void btnCancelActionPerformed(java.awt.event.ActionEvent evt) {// GEN-FIRST:event_btnCancelActionPerformed
		dispose();
	}// GEN-LAST:event_btnCancelActionPerformed

	/**
	 * Loads the {@code IrciData} and shows the structure of the monomer.
	 * 
	 * @param evt
	 */

	private void initMonomerViewers() {
		Insets oldInsets = UIManager
				.getInsets("TabbedPane.contentBorderInsets");
		UIManager.put("TabbedPane.contentBorderInsets", new Insets(0, 0, 0, 0));

		monomerViewer = new MonomerViewer();
		tpMonomerDetails.add(monomerViewer);
		// Tabs bar is invisible, because unneeded
		tpMonomerDetails.setUI(new BasicTabbedPaneUI() {
			@Override
			protected int calculateTabAreaHeight(int tabl_placement,
					int run_count, int max_tab_height) {
				return 0;
			}
		});

		UIManager.put("TabbedPane.contentBorderInsets", oldInsets);
	}

	private void initAttachmentTable() {
		attachmentTableModel = new AttachmentTableModel(
				new LinkedList<Attachment>());
		tblAttachments.setModel(attachmentTableModel);
		tblAttachments.putClientProperty("terminateEditOnFocusLost",
				Boolean.TRUE);
	}

	/**
	 * Closes the dialog and frees any resources.
	 */
	public void close() {
		setVisible(false);
		dispose();
	}

	private void registerInLocalMonomerStore(Monomer monomer) throws Exception {
		MonomerFactory factory = MonomerFactory.getInstance();
		MonomerStore store = factory.getMonomerStore();
		String smiles = monomer.getCanSMILES();
		if (!store.getSmilesMonomerDB().containsKey(smiles)) {

			store.addMonomer(monomer, true);
			factory.saveMonomerCache();
			LOG.info(String.format("Adding %s as %s to local monomer store",
					monomer.getCanSMILES(), monomer.getName()));
		} else {
			throw new Exception();
		}
	}

}
